package interviewquestions.Fundamentals;

public interface Fundamentals {
    /*
    1. Explain the process of Java code compilation and execution



Compilation: Java source code (.java file) is converted into bytecode (.class file) using the javac compiler.
Execution: The Java Virtual Machine (JVM) reads the bytecode and translates it into machine code, which is then executed by the computer's processor.


2. What is bytecode?

Bytecode is an intermediate-level, platform-independent code generated by the Java compiler. 
It is a set of instructions that the JVM can understand and execute.

3. What is the difference between bytecode and source code?

Feature	Source Code	Bytecode
Definition	Human-readable instructions written in a programming language (e.g., Java).	
Intermediate code compiled from source code.
Readability	Easily understood by humans.	Understood by JVM only.
Platform Dependence	Platform-independent once compiled.	Platform-independent.
Example	System.out.println("Hello, World!");	Binary instructions in .class file.


4. What is machine code?

Machine code is low-level code directly executed by a computerâ€™s processor. 
It consists of binary instructions (0s and 1s) specific to the hardware architecture.

5. What is the difference between bytecode and machine code?

Feature	                     Bytecode	                           Machine Code
Platform Dependence	  Platform-independent. 	                  Platform-specific.
Execution	        Executed by a virtual machine (e.g., JVM).	    Directly executed by the CPU.
Format	                 Intermediate representation.	           Binary code in 0s and 1s.


6. What is JVM? Is it same or different for different Operating Systems?

The Java Virtual Machine (JVM) is software that interprets and executes Java bytecode.
JVM is different for each operating system because it is implemented based on the underlying OS and hardware.''
However, it provides a consistent environment for running Java programs.

7. What are the major components of JVM?

Class Loader: Loads .class files (bytecode) into the JVM.
Method Area: Stores metadata, method code, and constants.
Heap: Stores objects and instance variables.
Stack: Holds method-level data like local variables and partial results.
Execution Engine: Converts bytecode to machine code.
Native Method Interface: Allows interaction with non-Java code.
Garbage Collector: Automatically removes unused objects.

8. What is the role of Class Loader in JVM?
The Class Loader is responsible for:

Loading: Finding and loading bytecode files into memory.
Linking: Verifying and preparing the loaded classes.
Initialization: Assigning default values to variables and executing static blocks.

9. What is the role of the Execution Engine in JVM?

The Execution Engine is responsible for:

Interpreting: Reading and executing bytecode instructions line by line.
Just-In-Time (JIT) Compilation: Converts frequently used bytecode into machine code for faster execution.
10. What are machine instructions?
Machine instructions are binary-coded commands (e.g., 1010 0001) that are directly executed by the processor to perform tasks like arithmetic operations, memory access, or data manipulation.
    

What is a package?
A package is a way to organize related classes and interfaces in Java.
It acts like a folder in a file system.
For example, java.util is a package that contains utility classes like ArrayList, HashMap, etc.

Why use it?
To avoid class name conflicts.
To make it easier to find, use, and maintain code.

Why do you need to import packages?
Importing a package allows you to use classes and methods from that package in your code without typing their full names every time.

For example, instead of writing java.util.ArrayList, you can just write ArrayList after importing it with:
java
Copy code
import java.util.ArrayList;
Why do you need to specify access modifiers?
Access modifiers (like public, private, protected, and default) control the visibility of classes, methods, and variables.

Why specify them?
To protect sensitive data or methods.
To define which parts of your code can be accessed from other classes.
For example, marking a variable as private ensures it cannot be directly accessed from outside the class, improving encapsulation.

What is static import?
A static import allows you to use static members (variables or methods) of a class without using the class name.

For example:
Instead of writing:

java
Copy code
System.out.println(Math.sqrt(16));
You can write:

java
Copy code
import static java.lang.Math.*;  
System.out.println(sqrt(16));

Why use it?

To make code shorter and cleaner when working with many static methods or constants.


What is the difference between argument and parameter?
A parameter is a variable defined in the method's definition.
Example:

java
Copy code
void greet(String name) {  // "name" is the parameter.
    System.out.println("Hello, " + name);
}
An argument is the actual value passed to the method when you call it.
Example:

java
Copy code
greet("John");  // "John" is the argument.
Key Difference:

Parameter: Placeholder in the method definition.
Argument: Actual data provided during the method call.



*/

}
